// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

package gowsdl

var schemaHeader = `
// Code generated by gowsdl DO NOT EDIT.
package {{goPackage}}

import (
	{{goImports}}
)

`

var schemaTmpl = `
{{ $targetNamespace := .TargetNamespace }}

{{define "SimpleType"}}
	{{$typeName := findTypeName .Name }}
	{{if .Doc}} {{.Doc | comment}} {{end}}
	{{if ne .List.ItemType ""}}
		type {{$typeName}} []{{findTypeNillable .List.ItemType true }}
	{{else if ne .Union.MemberTypes ""}}
		type {{$typeName}} string
	{{else if .Union.SimpleType}}
		type {{$typeName}} string
	{{else if .Restriction.Base}}
		type {{$typeName}} {{findTypeNillable .Restriction.Base true }}
    {{else}}
		type {{$typeName}} interface{}
	{{end}}

	{{if .Restriction.Enumeration}}
	const (
		{{with .Restriction}}
			{{range .Enumeration}}
				{{if .Doc}} {{.Doc | comment}} {{end}}
				{{$typeName}}{{$value := findTypeName .Value}} {{$typeName}} = "{{goString .Value}}" {{end}}
		{{end}}
	)
	{{end}}
{{end}}

{{define "ComplexContent"}}
	{{$baseType := findTypeNillable .Extension.Base true}}
	{{ if $baseType }}
		{{$baseType}}
	{{end}}

	{{template "Elements" .Extension.Sequence}}
	{{template "Elements" .Extension.Choice}}
	{{template "Elements" .Extension.SequenceChoice}}
	{{template "Attributes" .Extension.Attributes}}
{{end}}

{{define "ComplexContentWith"}}
	{{ $items := get . "items" }}
	{{ $typeName := get . "typeName" }}

	{{ $baseType := findTypeNillable $items.Extension.Base false }}
	{{ if $baseType }}
		{{ $fieldName := $baseType }}
		{{ $paramName := $fieldName | untitle }}
		func (o *{{ $typeName }}) With{{ $fieldName }}({{ $paramName }} *{{ $baseType }}) *{{ $typeName }} {
			o.{{ $fieldName }} = {{ $paramName }}
			return o
		}
	{{end}}

	{{template "ElementsWith" dict "items" $items.Extension.Sequence "typeName" $typeName }}
	{{template "ElementsWith" dict "items" $items.Extension.Choice "typeName" $typeName }}
	{{template "ElementsWith" dict "items" $items.Extension.SequenceChoice "typeName" $typeName }}
	{{template "AttributesWith" dict "items" $items.Extension.Attributes "typeName" $typeName}}
{{end}}

{{define "Attributes"}}
    {{ $targetNamespace := getNS }}
	{{range .}}
		{{if .Doc}} {{.Doc | comment}} {{end}}
		{{ $type := "string" }}
		{{ if ne .Type "" }}
			{{ $type = findTypeNillable .Type false }}
		{{ end }}
		{{ if ne $type "bool" }}
			{{ normalize .Name | makeFieldPublic}} {{$type}} ` + "`" + `xml:"{{.Name}},attr,omitempty" json:"{{.Name}},omitempty"` + "`" + `
		{{ else }}
			{{ normalize .Name | makeFieldPublic}} {{$type}} ` + "`" + `xml:"{{.Name}},attr" json:"{{.Name}}"` + "`" + `
		{{ end }}
	{{end}}
{{end}}

{{define "AttributesWith"}}
	{{ $items := get . "items" }}
	{{ $typeName := get . "typeName" }}
	{{ range $items }}
    	{{ $type := "string" }}
		{{ if ne .Type "" }}
			{{ $type = findTypeNillable .Type false }}
		{{ end }}
		{{ $fieldName := normalize .Name | makeFieldPublic }}
		{{ $paramName := $fieldName | untitle }}
		func (o *{{ $typeName }}) With{{ $fieldName  }}({{ $paramName }} {{ $type }}) *{{ $typeName }} {
			o.{{ $fieldName }} = {{ $paramName }}
			return o
		}
	{{end}}
{{end}}

{{define "SimpleContent"}}
	Value {{findTypeNillable .Extension.Base true}} ` + "`xml:\",chardata\" json:\"-,\"`" + `
	{{template "Attributes" .Extension.Attributes}}
{{end}}

{{define "SimpleContentWith"}}
	{{ $items := get . "items" }}
	{{ $typeName := get . "typeName" }}
	{{ $fieldName := "Value" }}
	{{ $paramName := $fieldName | untitle }}
	func (o *{{ $typeName }}) With{{ $fieldName }}({{ $paramName }} {{ findTypeNillable .Extension.Base true }}) *{{ $typeName }} {
		o.{{ $fieldName }} = {{ $paramName }}
		return o
	}
	{{template "AttributesWith" dict "items" $items.Extension.Attributes "typeName" $typeName}}
{{end}}

{{define "ComplexTypeInline"}}
	{{findTypeName .Name }} {{if eq .MaxOccurs "unbounded"}}[]{{end}}struct {
	{{with .ComplexType}}
		{{if ne .ComplexContent.Extension.Base ""}}
			{{template "ComplexContent" .ComplexContent}}
		{{else if ne .SimpleContent.Extension.Base ""}}
			{{template "SimpleContent" .SimpleContent}}
		{{else}}
			{{template "Elements" .Sequence}}
			{{template "Elements" .Choice}}
			{{template "Elements" .SequenceChoice}}
			{{template "Elements" .All}}
			{{template "Attributes" .Attributes}}
		{{end}}
	{{end}}
	} ` + "`" + `xml:"{{.Name}},omitempty" json:"{{.Name}},omitempty"` + "`" + `
{{end}}

{{define "Elements"}}
	{{range .}}
		{{if ne .Ref ""}}
			{{removeNS .Ref | replaceReservedWords  | makePublic}} {{if eq .MaxOccurs "unbounded"}}[]{{end}}{{findTypeNillable .Ref true }} ` + "`" + `xml:"{{.Ref | removeNS}},omitempty" json:"{{.Ref | removeNS}},omitempty"` + "`" + `
		{{else}}
		{{if not .Type}}
			{{if .SimpleType}}
				{{if .Doc}} {{.Doc | comment}} {{end}}
				{{if ne .SimpleType.List.ItemType ""}}
					{{ normalize .Name | makeFieldPublic}} []{{findTypeNillable .SimpleType.List.ItemType true}} ` + "`" + `xml:"{{.Name}},omitempty" json:"{{.Name}},omitempty"` + "`" + `
				{{else}}
					{{ normalize .Name | makeFieldPublic}} {{findTypeNillable .SimpleType.Restriction.Base true}} ` + "`" + `xml:"{{.Name}},omitempty" json:"{{.Name}},omitempty"` + "`" + `
				{{end}}
			{{else}}
				{{template "ComplexTypeInline" .}}
			{{end}}
		{{else}}
			{{if .Doc}}{{.Doc | comment}} {{end}}
			{{ $type := findTypeNillable .Type true }}
			{{ if ne $type "bool" }}
				{{replaceAttrReservedWords .Name | makeFieldPublic}} {{if eq .MaxOccurs "unbounded"}}[]{{end}}{{$type}} ` + "`" + `xml:"{{.Name}},omitempty" json:"{{.Name}},omitempty"` + "`" + `
			{{ else }}
				{{replaceAttrReservedWords .Name | makeFieldPublic}} {{if eq .MaxOccurs "unbounded"}}[]{{end}}{{$type}} ` + "`" + `xml:"{{.Name}}" json:"{{.Name}}"` + "`" + `
			{{ end }}{{end}}
		{{end}}
	{{end}}
{{end}}

{{define "ElementsWith"}}
	{{ $items := get . "items" }}
	{{ $typeName := get . "typeName" }}
	{{ range $items }}
		{{if ne .Ref ""}}
			{{ $fieldName := removeNS .Ref | replaceReservedWords | makeFieldPublic }}
			{{ $paramName := $fieldName | untitle }}
			func (o *{{ $typeName }}) With{{ $fieldName }}({{ $paramName }} {{if eq .MaxOccurs "unbounded"}}[]{{end}}{{ findTypeNillable .Ref true }}) *{{ $typeName }} {
				o.{{ $fieldName }} = {{ $paramName }}
				return o
			}

			{{if eq .MaxOccurs "unbounded"}}func (o *{{ $typeName }}) With{{ $fieldName }}Append({{ $paramName }} {{ findTypeNillable .Ref true }}) *{{ $typeName }} {
				o.{{ $fieldName }} = append(o.{{ $fieldName }}, {{ $paramName }})
				return o
			}{{end}}
		{{else}}
		{{if not .Type}}
			{{if .SimpleType}}
				{{if ne .SimpleType.List.ItemType ""}}
					{{ $fieldName := normalize .Name | replaceReservedWords | makeFieldPublic }}
					{{ $paramName := $fieldName | untitle }}
					func (o *{{ $typeName }}) With{{ $fieldName }}({{ $paramName }} []{{ findTypeNillable .SimpleType.List.ItemType true }}) *{{ $typeName }} {
						o.{{ $fieldName }} = {{ $paramName }}
						return o
					}

					func (o *{{ $typeName }}) With{{ $fieldName }}Append({{ $paramName }} {{ findTypeNillable .SimpleType.List.ItemType true }}) *{{ $typeName }} {
						o.{{ $fieldName }} = append(o.{{ $fieldName }}, {{ $paramName }})
						return o
					}
				{{else}}
					{{ $fieldName := normalize .Name | replaceReservedWords | makeFieldPublic }}
					{{ $paramName := $fieldName | untitle }}
					func (o *{{ $typeName }}) With{{ $fieldName }}({{ $paramName }} {{ findTypeNillable .SimpleType.Restriction.Base true }}) *{{ $typeName }} {
						o.{{ $fieldName }} = {{ $paramName }}
						return o
					}
				{{end}}
			{{end}}
		{{else}}
			{{ $fieldName := replaceAttrReservedWords .Name | makeFieldPublic }}
			{{ $paramName := $fieldName | untitle }}
			func (o *{{ $typeName }}) With{{ $fieldName  }}({{ $paramName }} {{if eq .MaxOccurs "unbounded"}}[]{{end}}{{ findTypeNillable .Type true }}) *{{ $typeName }} {
				o.{{ $fieldName }} = {{ $paramName }}
				return o
			}
			{{if eq .MaxOccurs "unbounded"}}func (o *{{ $typeName }}) With{{ $fieldName }}Append({{ $paramName }} {{ findTypeNillable .Type true }}) *{{ $typeName }} {
				o.{{ $fieldName }} = append(o.{{ $fieldName }}, {{ $paramName }})
				return o
			}{{end}}{{end}}
		{{end}}
	{{end}}
{{end}}

{{define "Any"}}
	{{range .}}
		Items     []string ` + "`" + `xml:",any" json:"items,omitempty"` + "`" + `
	{{end}}
{{end}}

{{define "AnyWith"}}
	{{ $items := get . "items" }}
	{{ $typeName := get . "typeName" }}
	{{ range $items }}
		{{ $fieldName := "Items" }}
		{{ $paramName := "items" }}
		func (o *{{ $typeName }}) With{{ $fieldName  }}({{ $paramName }} []sting) *{{ $typeName }} {
			o.{{ $fieldName }} = {{ $paramName }}
			return o
		}

		func (o *{{ $typeName }}) With{{ $fieldName  }}Append({{ $paramName }} sting) *{{ $typeName }} {
			o.{{ $fieldName }} = append(o.{{ $fieldName }}, {{ $paramName }})
			return o
		}
	{{end}}
{{end}}

{{range .SimpleType}}
	{{template "SimpleType" .}}
{{end}}

{{range .Elements}}
	{{$name := .Name }}
	{{$typeName := findTypeName .Name }}
	{{if not .Type}}
		{{/* ComplexTypeLocal */}}
		{{with .ComplexType}}
			type {{$typeName}} struct {
				XMLName xml.Name
				{{if ne .ComplexContent.Extension.Base ""}}
					{{template "ComplexContent" .ComplexContent}}
				{{else if ne .SimpleContent.Extension.Base ""}}
					{{template "SimpleContent" .SimpleContent}}
				{{else}}
					{{template "Elements" .Sequence}}
					{{template "Any" .Any}}
					{{template "Elements" .Choice}}
					{{template "Elements" .SequenceChoice}}
					{{template "Elements" .All}}
					{{template "Attributes" .Attributes}}
				{{end}}
			}
			func New{{$typeName}}As(tagName string) *{{$typeName}} {
				return &{{$typeName}}{XMLName: xml.Name{Space: "{{$targetNamespace}}", Local: tagName}}
			}
			func New{{$typeName}}() *{{$typeName}} {
				return New{{$typeName}}As("{{$name}}")
			}
			{{if ne .ComplexContent.Extension.Base ""}}
				{{ template "ComplexContentWith" dict "items" .ComplexContent "typeName" $typeName }}
			{{else if ne .SimpleContent.Extension.Base ""}}
				{{ template "SimpleContentWith" dict "items" .SimpleContent "typeName" $typeName }}
			{{else}}
				{{ template "ElementsWith" dict "items" .Sequence "typeName" $typeName }}
				{{ template "AnyWith" dict "items" .Any "typeName" $typeName }}
				{{ template "ElementsWith" dict "items" .Choice "typeName" $typeName }}
				{{ template "ElementsWith" dict "items" .SequenceChoice "typeName" $typeName }}
				{{ template "ElementsWith" dict "items" .All "typeName" $typeName }}
				{{ template "AttributesWith" dict "items" .Attributes "typeName" $typeName }}
			{{end}}
		{{end}}
		{{/* SimpleTypeLocal */}}
		{{with .SimpleType}}
			{{if .Doc}} {{.Doc | comment}} {{end}}
			{{if ne .List.ItemType ""}}
				type {{$typeName}} []{{findTypeNillable .List.ItemType true }}
			{{else if ne .Union.MemberTypes ""}}
				type {{$typeName}} string
			{{else if .Union.SimpleType}}
				type {{$typeName}} string
			{{else if .Restriction.Base}}
				type {{$typeName}} {{findTypeNillable .Restriction.Base true }}
			{{else}}
				type {{$typeName}} interface{}
			{{end}}

			{{if .Restriction.Enumeration}}
			const (
				{{with .Restriction}}
					{{range .Enumeration}}
						{{if .Doc}} {{.Doc | comment}} {{end}}
						{{$typeName}}{{$value := findTypeName .Value}} {{$typeName}} = "{{goString .Value}}" {{end}}
				{{end}}
			)
			{{end}}
		{{end}}
	{{else}}
		{{$type := findTypeNillable .Type .Nillable}}
		{{if ne ($typeName) ($type)}}
			type {{$typeName}} {{$type}}
			{{if eq ($type) ("soap.XSDDateTime")}}
				func (xdt {{$typeName}}) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
					return soap.XSDDateTime(xdt).MarshalXML(e, start)
				}

				func (xdt *{{$typeName}}) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
					return (*soap.XSDDateTime)(xdt).UnmarshalXML(d, start)
				}
			{{else if eq ($type) ("soap.XSDDate")}}
				func (xd {{$typeName}}) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
					return soap.XSDDate(xd).MarshalXML(e, start)
				}

				func (xd *{{$typeName}}) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
					return (*soap.XSDDate)(xd).UnmarshalXML(d, start)
				}
			{{else if eq ($type) ("soap.XSDTime")}}
				func (xt {{$typeName}}) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
					return soap.XSDTime(xt).MarshalXML(e, start)
				}

				func (xt *{{$typeName}}) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
					return (*soap.XSDTime)(xt).UnmarshalXML(d, start)
				}
			{{end}}
		{{end}}
	{{end}}
{{end}}

{{range .ComplexTypes}}
	{{/* ComplexTypeGlobal */}}
	{{$name := .Name }}
	{{$typeName := findTypeName .Name }}
	{{ log "generate complex type" .Name "as" $typeName }}
	{{if and (eq (len .SimpleContent.Extension.Attributes) 0) (eq (findTypeNillable .SimpleContent.Extension.Base true) "string") }}
		type {{$typeName}} string
	{{else}}
		type {{$typeName}} struct {
				XMLName xml.Name
			{{if ne .ComplexContent.Extension.Base ""}}
				{{template "ComplexContent" .ComplexContent}}
			{{else if ne .SimpleContent.Extension.Base ""}}
				{{template "SimpleContent" .SimpleContent}}
			{{else}}
				{{template "Elements" .Sequence}}
				{{template "Any" .Any}}
				{{template "Elements" .Choice}}
				{{template "Elements" .SequenceChoice}}
				{{template "Elements" .All}}
				{{template "Attributes" .Attributes}}
			{{end}}
		}

		func New{{$typeName}}As(tagName string) *{{$typeName}} {
			return &{{$typeName}}{XMLName: xml.Name{Space: "{{$targetNamespace}}", Local: tagName}}
		}
		func New{{$typeName}}() *{{$typeName}} {
			return New{{$typeName}}As("{{$name}}")
		}
		{{if ne .ComplexContent.Extension.Base ""}}
			{{ template "ComplexContentWith" dict "items" .ComplexContent "typeName" $typeName }}
		{{else if ne .SimpleContent.Extension.Base ""}}
			{{ template "SimpleContentWith" dict "items" .SimpleContent "typeName" $typeName }}
		{{else}}
			{{ template "ElementsWith" dict "items" .Sequence "typeName" $typeName }}
			{{ template "AnyWith" dict "items" .Any "typeName" $typeName }}
			{{ template "ElementsWith" dict "items" .Choice "typeName" $typeName }}
			{{ template "ElementsWith" dict "items" .SequenceChoice "typeName" $typeName }}
			{{ template "ElementsWith" dict "items" .All "typeName" $typeName }}
			{{ template "AttributesWith" dict "items" .Attributes "typeName" $typeName }}
		{{end}}
	{{end}}
{{end}}

`
